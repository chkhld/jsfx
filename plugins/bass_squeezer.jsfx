// Bass Squeezer
//
// Split-band compression and filtered distortion for that instant bathtub bass.
//
// It's a relatively simple thing, really. You throw this on a bass track, DI or
// amped, and observe what happens. Instantly pushes the lows up to blow out the
// subwoofer, cuts out the annoying lower mids, and distorts the high end to let
// it pierce through the rest of your mix.
//
// If one of the Mono input routings is selected, only one channel is processed,
// which leads to less CPU munch than stereo mode, which processes two channels.
//
// The Split Low setting defines the frequency at which the filter separates the
// low end from the rest. The Split High slider defines the cutoff frequency for
// the filter that separates the high end from the rest. If both sliders are NOT
// set to the same cutoff frequency, which will usually be the case, all content
// between the two filter cutoffs will be rejected, essentially creating a notch
// filter for the low mids of variable bandwidth, depending on the two cutoffs.
//
// Turning up the Squeeze Lows slider will compress the low end harder.
//
// Turning up the Squeeze Highs slider compresses and distorts the high band. It
// will also lower a high-cut filter that narrows the high band down towards the
// Split Low cutoff to focus and pronounce the distortion.
//
// The default setting should give you a good starting point. Try changing Split
// High first, and see if lowering or raising it sits better around your bass-es
// high end. If you want more high buzz, increase High Trim. If the distortion's
// really scratchy and nasty, lower High Trim until it's acceptable. It's always
// possible to compensate volume balance differences with the Low Trim/High Trim
// sliders.
//
// author: chokehold
// url:    https://github.com/chkhld/jsfx/
// tags:   bass distortion compression multiband filter
//
desc: Bass Squeezer

slider1:routing=0<0,3,{Mono (only L),Mono (only R),Mono (L+R),Stereo}>Input routing
slider2
slider3:dBGain=0<-24,24,0.01>Input Gain [dB]
slider4
slider5:hzSplitLo=150<100,500,1>Split Low [Hz]
slider6:hzSplitHi=1000<500,2500,1>Split High [Hz]
slider7
slider8:procLo=50<0,100,1>Squeeze Lows [%]
slider9:procHi=50<0,100,1>Squeeze Highs [%]
slider10
slider11:dBLo=0<-12,12,0.01>Low Trim [dB]
slider12:dBHi=0<-12,12,0.01>High Trim [dB]
slider13
slider14:wetMix=100<0,100,1>Wet Blend [%]
slider15
slider16:dBTrim=0<-24,24,0.1>Output Trim [dB]

in_pin:Input L
in_pin:Input R
out_pin:Output L
out_pin:Output R

@init
  
  // Converts dB values to float gain factors
  function dBToGain (decibels) (pow(10, decibels * 0.05));
  //
  // Constants required for gainTodB
  M_LN10_20   = 8.68588963806503655302257837833210164588794011607333;
  FLOAT_FLOOR = 0.0000000630957; // gainTodB --> ~ -144 dBfs
  //
  // Converts float gain factors to dB values
  function gainTodB (float) (log(max(FLOAT_FLOOR, abs(float))) * M_LN10_20);
  
  // SINE CLIPPING -------------------------------------------------------------
  //
  // The output of the sine function is within the range [-1,+1] as long as its
  // input stays inside the range [-1/2π,+1/2π]. This is perfect to create soft
  // overdrive, with less distortion than common hyperbolic tangent saturation.
  //
  // This type of clipping doesn't use a ceiling, if you want one then you have
  // to boost the signal into this function first, and attenuate it later on by
  // the factor 1/boost.
  //
  halfPi = $pi * 0.5;
  //
  function sineClip (sample) local (above, below, overs, polarity)
  (
    // Evaluate whether the sample is outside of range [-1/2π,+1/2π]
    above = (sample > halfPi);
    below = (sample < -halfPi);
    overs = (above || below);
    
    // If the sample is outside [-1/2π,+1/2π] then output the sample's polarity,
    // which will always be either -1 or +1, making it a perfect 0 dBfs ceiling
    // value for hard clipping. If the sample is inside [-1/2π,+1/2π], then run
    // it through the sin() function, which returns values in range [-1,+1] for
    // peak sample values up to 1/2π, so well over the usual 0 dBfs hard limit.
    //
    sample = overs * sign(sample) + !overs * sin(sample);
  );
  
  // LINKWITZ-RILEY 4TH ORDER FILTER -------------------------------------------
  //
  // Implemented after Lubomir I. Ivanov
  // https://www.musicdsp.org/en/latest/Filters/266-4th-order-linkwitz-riley-filters.html
  //
  // Per-sample processing function
  //
  function lr4Tick (sample) instance (a0,a1,a2,a3,a4,b0,b1,b2,b3,xm0,xm1,xm2,xm3,ym0,ym1,ym2,ym3) 
                            local    (buffer)
  (
    buffer = sample;
    sample = a0*sample + a1*xm0 + a2*xm1 + a3*xm2 + a4*xm3 - b0*ym0 - b1*ym1 - b2*ym2 - b3*ym3;
    xm3 = xm2; xm2 = xm1; xm1 = xm0; xm0 = buffer;
    ym3 = ym2; ym2 = ym1; ym1 = ym0; ym0 = sample;
    sample;
  );
  //
  // Low pass filter
  //
  function lr4LP (SR, Hz) instance (a0,a1,a2,a3,a4,b0,b1,b2,b3,xm0,xm1,xm2,xm3,ym0,ym1,ym2,ym3) 
                          local    (sq_tmp1,sq_tmp2,sq2_tmp1,sq2_tmp2,a_tmp)
  (
    wc  = 2*$pi*Hz; wc2 = wc*wc; wc3 = wc2*wc; wc4 = wc2*wc2; wc2x4 = wc2*4; wc4x6 = wc4*6;
    k  = wc/tan($pi*Hz/SR); k2 = k*k; k3 = k2*k; k4 = k2*k2;
    sq_tmp1 = sqrt(2)*wc3*k; sq_tmp2 = sqrt(2)*wc*k3;
    sq2_tmp1 = 2*sq_tmp1; sq2_tmp2 = 2*sq_tmp2;
    a_tmp = 4*wc2*k2+2.0*sq_tmp1+k4+2.0*sq_tmp2+wc4;
    b0 = (4.0 * (wc4 + sq_tmp1 - k4 - sq_tmp2))  / a_tmp;
    b1 = (6.0 * wc4 - 8.0 * wc2 * k2 + 6.0 * k4) / a_tmp;
    b2 = (4.0 * (wc4 - sq_tmp1 + sq_tmp2 - k4))  / a_tmp;
    b3 = (k4 - 2.0 * sq_tmp1 + wc4 - 2.0 * sq_tmp2 + 4.0 * wc2 * k2) / a_tmp;
    a0 = wc4/a_tmp; a1 = 4*wc4/a_tmp; a2 = 6*wc4/a_tmp; a3 = a1; a4 = a0;
    xm0=xm1=xm2=xm3=ym0=ym1=ym2=ym3=0.0;
  );
  //
  // High pass filter
  //
  function lr4HP (SR, Hz) instance (a0,a1,a2,a3,a4,b0,b1,b2,b3,xm0,xm1,xm2,xm3,ym0,ym1,ym2,ym3) 
                          local    (sq_tmp1,sq_tmp2,sq2_tmp1,sq2_tmp2,a_tmp)
  (
    wc  = 2*$pi*Hz; wc2 = wc*wc; wc3 = wc2*wc; wc4 = wc2*wc2; wc2x4 = wc2*4; wc4x6 = wc4*6;
    k  = wc/tan($pi*Hz/SR); k2 = k*k; k3 = k2*k; k4 = k2*k2;
    sq_tmp1 = sqrt(2)*wc3*k; sq_tmp2 = sqrt(2)*wc*k3;
    sq2_tmp1 = 2*sq_tmp1; sq2_tmp2 = 2*sq_tmp2;
    a_tmp = 4*wc2*k2+2.0*sq_tmp1+k4+2.0*sq_tmp2+wc4;
    b0 = (4.0 * (wc4 + sq_tmp1 - k4 - sq_tmp2))  / a_tmp;
    b1 = (6.0 * wc4 - 8.0 * wc2 * k2 + 6.0 * k4) / a_tmp;
    b2 = (4.0 * (wc4 - sq_tmp1 + sq_tmp2 - k4))  / a_tmp;
    b3 = (k4 - 2.0 * sq_tmp1 + wc4 - 2.0 * sq_tmp2 + 4.0 * wc2 * k2) / a_tmp;
    a0 = k4 / a_tmp; a1 = -4 * k4 / a_tmp; a2 = 6 * k4 / a_tmp; a3 = a1; a4 = a0;
    xm0=xm1=xm2=xm3=ym0=ym1=ym2=ym3=0.0;
  );
  
  // ATTACK / RELEASE ENVELOPE
  //
  // This will turn a variable into a full envelope container that
  // holds an envelope state as well as two time coefficients used
  // for separate attack and release timings.
  //
  function attRelSetup (msAttack, msRelease) instance (coeffAtt, coeffRel) local ()
  (
    // Set attack and release time coefficients
    coeffAtt = exp(-1000 / (msAttack  * srate));
    coeffRel = exp(-1000 / (msRelease * srate));
  );
  //
  // This calculates the new envelope state for the current sample.
  // If the current sample is above the current envelope state, let
  // the attack envelope run. And if the current sample is below the
  // the current envelope state, then let the release envelope run.
  // 
  // The sample should already be abs()-ed by here to dBfs
  //
  function attRelTick (dBsample) instance (envelope, coeffAtt, coeffRel) local (above, change)
  (
    above  = (dBsample > envelope);
    change = envelope - dBsample;
    
    // If above, calculate attack + if not above, calculate release
    envelope = (above * (dBsample + coeffAtt * change)) + (!above * (dBsample + coeffRel * change));
  );
  
  // GAIN CALCULATOR
  //
  // From all the various levels, this will calculate more
  // values required to calculate with later on.
  //
  function gainCalcSetup (dBThreshold, fullRatio, dBKnee) instance (threshold, ratio, makeup, knee, kneeWidth, kneeUpper, kneeLower) local ()
  (
    threshold = dBThreshold;  // signed dBfs
    ratio = 1 / fullRatio;    // 1/x --> compression < 1, expansion > 1
    makeup = dBToGain(abs((threshold + (abs(threshold) * ratio)) * 0.4));
    knee = dBKnee;
    kneeWidth = knee * 0.5;
    kneeUpper = threshold + kneeWidth;
    kneeLower = threshold - kneeWidth;
  );
  //
  function gainCalcTick (dBsample) instance (ratio, knee, kneeLower, kneeUpper, threshold) local (dBReduction, slope)
  (
    dBReduction = dBsample;
    slope = 1.0 - ratio;
    
    // If the signal is inside the confines of the set Soft Knee,
    // calculate the appropriate "soft" reduction here.
    (knee > 0.0) && (dBsample > kneeLower) && (dBsample < kneeUpper) ?
    (
      slope *= ((dBsample - kneeLower) / knee) * 0.5;
      dBReduction = slope * (kneeLower - dBsample);
    ):(
      dBReduction = min(0.0, slope * (threshold - dBsample));
    );
    
    // Return the gain reduction float factor
    dBToGain(dBReduction);
  );
  
  // COMPRESSOR
  //
  // Finally, now all the individual components created
  // earlier are combined into a single big compressor.
  //
  // Full ratio: >1 for compression, <1 for expansion
  // dBThreshold: signed dBfs
  // dBKnee: absolute/positive dB
  //
  function compSetup (msAttack, msRelease, dBThreshold, fullRatio, dBKnee) instance (attRel, calc) local ()
  (
    attRel.attRelSetup(msAttack, msRelease);
    calc.gainCalcSetup(dbThreshold, fullRatio, dBKnee);
  );
  //
  function compTick (sample) instance (GR, attRel, calc) local ()
  (
    // Turn the key sample [-1;1] into a dBfs value and send it 
    // into the envelope follower.
    attRel.attRelTick(gainTodB(sample));
    
    // Calculate the required gain reduction for this input
    // sample based on user-specified parameters. This will
    // output the GR value as a float gain factor, NOT in dB.
    GR = calc.gainCalcTick(attRel.envelope);
    
    // This return value is the float factor gain adjustment
    // that needs to be applied to the signal sample, it is
    // NOT an actual sample value.
    GR * calc.makeup;
  );
  
  // Used to keep track of cutoff frequency changes
  lastLoFreq  = 0;
  lastHiFreq = 0;

@slider
  
  // Full spectrum input gain adjustment
  inputGain = dBToGain(dBGain);
  
  // Low and High band processing amounts (percent to [0,1])
  loWet = procLo * 0.01;
  loDry = 1.0 - loWet;
  
  hiWet = procHi * 0.01;
  hiDry = 1.0 - hiWet;
  
  // Only recalculate Low crossover filters if cutoff was changed
  (lastLoFreq != hzSplitLo) ?
  (
    // Update filter properties
    lpL.lr4LP(srate, hzSplitLo);
    lpR.lr4LP(srate, hzSplitLo);
    
    lastLoFreq = hzSplitLo;
  );
  
  // Only recalculate High crossover filters if cutoff was changed
  (lastHiFreq != hzSplitHi) ? 
  (
    hpL.lr4HP(srate, hzSplitHi);
    hpR.lr4HP(srate, hzSplitHi);
    
    hzHighCutMin = hzSplitHi * 2;
    hzHighCutFrq = hzHighCutMin + (hiDry * 10000);
    
    hcL.lr4LP(srate, hzHighCutFrq);
    hcR.lr4LP(srate, hzHighCutFrq);
    
    lastHiFreq = hzSplitHi;
  );
  
  // Set low band compressor characteristics
  attackLo = 101 - procLo; // 0% = 101ms, 50% = 51ms, 100% = 1ms
  releaseLo = 50 + (10 * procLo); // 0% = 50ms, 50% = 550ms, 100% = 1050ms
  thresholdLo = 0 - (36 * loWet); // 0% = 0 dBfs, 50% = -18 dBfs, 100% = -36 dBfs
  ratioLo = 1 + (7 * loWet); // 0% = 1:1, 50% = 1:4.5, 100% = 1:8
  kneeLo = (18 * loWet); // 0% = 0 dB, 50% = 6 dB, 100% = 12 dB
  
  // Set up low band compressors
  compLoL.compSetup(attackLo, releaseLo, thresholdLo, ratioLo, kneeLo);
  compLoR.compSetup(attackLo, releaseLo, thresholdLo, ratioLo, kneeLo);
  
  // High band saturation drive and compensation
  highDrive = dBToGain(hiWet * 48); // 0% = 0 dB, 50% = 12 dB, 100% = 24 dB
  highComp  = dBToGain(hiWet * -24);
  
  // Set high band compressor characteristics
  attackHi = 10 - (hiWet * 9); // 0% = 10ms, 50% = 6.5ms, 100% = 1ms
  releaseHi = 1 + (hiWet * 9); // 0% = 1ms, 50% 5.5ms, 100% 10ms
  thresholdHi = 0 - (12 * hiWet); // 0% = dBfs, 50% = -6 dBfs, 100% = -12 dBfs
  ratioHi = 1 + (10 * hiWet); // 0% = 1:1, 50% = 1:6, 10% = 1:11
  kneeHi = 18 - (12 * hiWet); // 0% = 18 dB, 50% = 12 dB, 100% = 6 dB
  
  // Set up high band compressors
  compHiL.compSetup(attackHi, releaseHi, thresholdHi, ratioHi, kneeHi);
  compHiR.compSetup(attackHi, releaseHi, thresholdHi, ratioHi, kneeHi);
  
  // Low and high band make-up gain adjustments
  loTrim = dBToGain(dBLo);
  hiTrim = dBToGain(dBHi);
  
  // Output gain trim
  outTrim = dBToGain(dBTrim);
  
  // Dry/Wet signal mix
  amountWet = wetMix * 0.01;
  amountDry = 1.0 - amountWet;
  
@sample
  
  // Mono operation
  (routing < 3) ?
  (
    // Pick the input signal depending on selected mono routing
    (routing == 0) ? input = spl0; // Mono (L)
    (routing == 1) ? input = spl1; // Mono (R)
    (routing == 2) ? input = (spl0+spl1) * 0.5; // Mono (L+R)
    
    // Apply full-band input gain
    signal = input * inputGain;
    
    // Split off low and high band signals
    wetLo = lpL.lr4Tick(signal);
    wetHi = hpL.lr4Tick(signal);
    
    // Process high band high-cut
    wetHi = hcL.lr4Tick(wetHi);
    
    // If low band squeeze enabled
    (loWet > 0.0) ? 
    (
      // Apply compression to low band
      wetLo *= compLoL.compTick(abs(wetLo));
      
      // Add some gentle post-compression harmonics to low band
      wetLo = (loDry * wetLo) + (loWet * sineClip(wetLo));
    );
    
    // If high band squeeze enabled
    (hiWet > 0.0) ?
    (
      // Apply drive (and compensation) to high band
      wetHi = (hiDry * wetHi) + (hiWet * sineClip(wetHi * highDrive) * highComp);
      
      // Apply compression to high band
      wetHi *= compHiL.compTick(abs(wetHi));
    );
    
    // Apply post-processing make-up gain to low and high bands
    wetLo *= loTrim;
    wetHi *= hiTrim;
    
    // Merge low and high bands into original signal
    signal = (amountDry * input) + (amountWet * (wetLo + wetHi));
    
    // Apply output trim to signal
    signal *= outTrim;
    
    // Copy final signal to both plugin outputs
    spl0 = spl1 = signal;
  )
  : // Stereo operation -- same as mono, just on separate channels
  (
    signalL = spl0 * inputGain;
    signalR = spl1 * inputGain;
    
    wetLoL = lpL.lr4Tick(signalL);
    wetLoR = lpR.lr4Tick(signalR);
    
    wetHiL = hpL.lr4Tick(signalL);
    wetHiR = hpR.lr4Tick(signalR);
    
    wetHiL = hcL.lr4Tick(wetHiL);
    wetHiR = hcR.lr4Tick(wetHiR);
    
    (loWet > 0.0) ? 
    (
      wetLoL *= compLoL.compTick(abs(wetLoL));
      wetLoR *= compLoR.compTick(abs(wetLoR));
    
      wetLoL = (loDry * wetLoL) + (loWet * sineClip(wetLoL));
      wetLoR = (loDry * wetLoR) + (loWet * sineClip(wetLoR));
    );
    
    (hiWet > 0.0) ?
    (
      wetHiL = (hiDry * wetHiL) + (hiWet * sineClip(wetHiL * highDrive) * highComp);
      wetHiR = (hiDry * wetHiR) + (hiWet * sineClip(wetHiR * highDrive) * highComp);
    
      wetHiL *= compHiL.compTick(abs(wetHiL));
      wetHiR *= compHiR.compTick(abs(wetHiR));
    );
    
    wetLoL *= loTrim;
    wetLoR *= loTrim;
    
    wetHiL *= hiTrim;
    wetHiR *= hiTrim;
    
    spl0 = (amountDry * spl0) + (amountWet * (wetLoL + wetHiL));
    spl1 = (amountDry * spl1) + (amountWet * (wetLoR + wetHiR));
    
    spl0 *= outTrim;
    spl1 *= outTrim;
  )
  
